import{_ as c,c as r,b as a,a as o,d as s,e as n,w as p,r as i,o as l}from"./app-B_sKV6fk.js";const h={};function A(g,e){const d=i("Annotation"),t=i("Mermaid");return l(),r("div",null,[e[5]||(e[5]=a('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>早在 2023 年就掀起了一阵<code>ChatGPt</code>的热潮，一石激起千层浪。<br> 彼时火热的还有<code>Web3</code>、<code>区块链</code>、<code>元宇宙</code>等概念，它们之间也有一定的关系，利用<code>区块链</code>的技术链接在<code>Web3</code>中的万事万物共同构成这个<code>元宇宙</code>，在这个宇宙中，万事万物都是虚拟的，但又可以对应到现实中的个体，类似电影《头号玩家》中展示的那样。只不过在国内，这些概念还不成熟，<code>区块链</code>在某些方面(如：合同、数字人民币)有一些应用，其他可能涉及到欺诈或合规问题，导致没有较大的发展，但仍有小公司在做。<br> 而 AI 的发展却是如火如荼，各种国内外的 AI 工具层出不穷，如：ChatGPT、Claude、Gemini、Kimi、DeepSeek、智谱清言、千问、豆包、腾讯元宝，等等。<br> 这些发展成果离不开科技公司的研发迭代，也离不开政策支持，国家队站台推进。随着技术发展，逐渐出现了越来越多 AI 相关的概念及专有词汇，这么多的概念及其之间的关系，可能会导致我们对 AI 的认知不够，而不能够有效的去利用 AI。那么，我们接下来就去尝试理解。</p><h2 id="_1-ai-名词" tabindex="-1"><a class="header-anchor" href="#_1-ai-名词"><span>1. AI 名词</span></a></h2><p>在 AI 名词一波又一波的冲击下，逐渐出现了如：<code>Agnet</code>、<code>Function Calling</code>、<code>MCP</code>，它们都是什么意思？<br> 有人说<code>Agent</code>是<code>智能体</code>，那么<code>智能体</code>又是什么意思？<br> 有人说<code>MCP</code>是 AI 时代的 USB 接口，那 <code>MCP</code> 能插U盘吗？</p><p>接下来我们把<code>Prompt</code>、<code>Agnet</code>、<code>Function Calling</code>、<code>MCP</code>这几个概念串起来，说一说在 AI 的发展下，它们各自是什么，以及相互之间有什么关系。现在就开始吧！</p><h3 id="_1-1-user-prompt" tabindex="-1"><a class="header-anchor" href="#_1-1-user-prompt"><span>1.1 User Prompt</span></a></h3>',6)),o("p",null,[e[1]||(e[1]=n("早在 2023 年 OpenAI 公司发布 ChatGPT 时",-1)),s(d,{label:"ChatGPT",total:1},{"item-0":p(()=>[...e[0]||(e[0]=[o("p",null,"彼时还有卖号以及代注册的，从15到5块钱，从人工到批量，但那些批量怎么来的，能用多久，会不会黑号就难说了。",-1)])]),_:1}),e[2]||(e[2]=n("，AI 看起来只是一个聊天框，我们通过聊天框发送一条消息给 AI 模型，模型就会给一个回复。我们发的消息就叫",-1)),e[3]||(e[3]=o("code",null,"User Prompt",-1)),e[4]||(e[4]=n("，也叫用户提示词，一般是我们提出的问题或者想对 AI 模型说的话。如下所示：",-1))]),s(t,{code:"eJwrTi0sTc1LTnXJTEwvSszlUlB4PmXFs47tCrp2dgqOns9WLHw6r9tK4cneBU+X7tUILU4tUggoys8tKNEEKoXJgxVD9MGUvt/T+GxO55PdDU92djzrmPi0f/2T3Uuf7lgHlH0+q+XphOnv98znAgCa00K7"}),e[6]||(e[6]=o("p",null,"但在现实生活中，面对不同身份的人，即便我们说出相同的话，对方也会根据自己的经历以及身份而给出不同的回复。而 AI 没有人设，就只会给出非常模板化的回答。当我说:“肚子疼”时不同角色给出的回应：",-1)),s(t,{code:"eJxLy8kvT85ILCpR8AniUlAoLk1KL0osyFB41jERyM01jH7RNOvp2gnPp+2JBfJT81JAokbRzzt2AFGsgq6unULN0wnNT5fMerKr7emE5fY1uYYgJcbRT5d1ABFUyfMp859PbwUrmQ5TYhL9dOnmZ3O6n/Z3wwza2PhkVzfQrPd7eoDk02lznzftfN689tmGLUCjFaH6TKMdPZ+tWPh0HlzbsqZnczqf7Oh92dD0Yv32pxs2Pu3ZrQdSDQCCIG1z"}),e[7]||(e[7]=a(`<p>但是 AI 这种四平八稳的回答就显得很无趣，于是我们给 AI 加上人设。最直接的方式是，把人设信息和我们要说的话打包成一条<code>User Prompt</code>发给 AI，如：<code>你扮演我女朋友，我现在肚子疼</code>，然后 AI 就可能回复：<code>我肚子也疼！</code>，这样就对味了。<br> 但是<code>你扮演我女朋友</code>这句话并不是我们想对 AI 说的话，每次对话都加上这句挺出戏的。于是我们把这句人设信息单独拎出来，放到另一个<code>Prompt</code>中，这就是<code>System Prompt</code>，即系统提示词。</p><h3 id="_1-2-system-prompt" tabindex="-1"><a class="header-anchor" href="#_1-2-system-prompt"><span>1.2 System Prompt</span></a></h3><p><code>System Prompt</code>主要用来描述 AI 的角色、性格、背景信息、语气等，总之就是一种固定状态的设置。不需要用户每次都告诉 AI 的信息，都可以放进系统提示词，设置一次就持续生效。<br> 当用户每次把<code>User Prompt</code>发给 AI 时，系统会自动把<code>System Prompt</code>一起发给 AI，这样对话就显得自然多了。比如 ChatGPT 网页版有<code>自定义 ChatGPT</code>设置，这些预设就会成为系统提示词的一部分。</p><h3 id="_1-3-agent" tabindex="-1"><a class="header-anchor" href="#_1-3-agent"><span>1.3 Agent</span></a></h3><p>不过，即使<code>System Prompt</code>设置的再完美，说到底它也只是个聊天机器人，顶多给你一些参考性回答，实际还是得自己动手操作，那能不能让它自己完成任务呢？<br> 第一个做出这种尝试的是一个叫<a href="https://github.com/Significant-Gravitas/AutoGPT" target="_blank" rel="noopener noreferrer">AutoGPT</a>的开源项目，它是一个本地运行的小程序。如果你想让 AI 帮你管理电脑上的文件，那就需要写一些文件管理的函数，如：列出/创建目录、上传/下载、移动/复制、读写文件等，然后把这些函数及描述和使用方法注册到 AutoGPT 中，AutoGPT 会自动根据这些信息生成<code>System Prompt</code>，告诉 AI 模型你有哪些工具，这些工具都是干什么的，以及 AI 如果要使用这些工具该返回什么格式(如，我要调用<code>read_dir</code>)，最后把这些<code>System Prompt</code>和<code>User Prompt</code>一同发给 AI 模型(如<code>帮我打开 host 文件目录</code>)。如果 AI 模型够聪明就会按照要求的格式返回给 AutoGPT，接着 AutoGPT 解析后执行相应的函数，再把函数结果返回给 AI 模型，然后 AI 再根据函数结果决定下一步该做什么。这个过程就一直反复，直到完成用户的要求。<br> 其实，像 AutoGPT 这种在<strong>AI模型</strong>、<strong>(函数)工具</strong>、<strong>用户</strong>之间传话的程序就叫做 AI <code>Agent</code>，理解为 AI 代理人的意思。这些提供给<code>Agent</code>的函数/服务/库等也叫做<code>Agent Tool</code>。</p><p>不过，这种模式还是存在一些小问题，虽然我们在<code>System Prompt</code>中写清楚了 AI 应该用什么格式返回，但 AI 它是一种概率模型，相同的问题不是每次返回得都一样，那就可能会存在返回格式不对的情况。<br> 为了应对这种情况，很多<code>Agent</code>就会在发现 AI 返回的格式不正确时<strong>自动重试</strong>，比如<a href="https://cline.bot/" target="_blank" rel="noopener noreferrer">Cline</a>仍采用这种模式，但这种反复尝试总归让人感觉不靠谱，并且<code>Agent</code>的开发需要处理重试的情况，最关键的是返回重试会带来更多额外的 Token 开销。<br> 于是一些大模型厂商，如：ChatGPT、Claude、Gemini 等，纷纷推出了叫做<code>Function Calling</code>的功能，这种功能的核心思想是：统一格式、规范描述。</p><h3 id="_1-4-function-calling" tabindex="-1"><a class="header-anchor" href="#_1-4-function-calling"><span>1.4 Function Calling</span></a></h3><p>回到之前的例子，当我们需要 AI 帮我打开 host 文件目录时，我们通过<code>System Prompt</code>告诉 AI 有哪些工具和应该返回什么格式，但这些描述是用自然语言随意写的，只要意思表达清楚就行。而<code>Function Calling</code>对这些描述进行了标准化，比如每个<code>Agent Tool</code>都用一个 JSON 对象来定义：</p><div class="language-json" data-highlighter="shiki" data-ext="json" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">  &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">name</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">list_dir</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">  &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">desc</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">列出目录</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">  &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">params</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">path</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">str</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>然后这些 JSON 对象也从<code>System Prompt</code>被剥离出来，单独放到一个字段中。<code>Function Calling</code>也规定了 AI 模型使用工具时返回格式，所以格式描述也可从<code>System Prompt</code>中去掉。这样一来，所有<code>Agent Tool</code>都统一放在相同的位置，工具描述也都是相同的格式，AI 使用工具后的回复也都依照相同的格式，于是就能更加有针对性的训练 AI 模型，让它里理解这种调用场景。此时如果 AI 模型还是生成了错误的返回格式时，但由于正确的返回格式已经明确指定了，AI 服务器就能检测到错误，于是就在服务器端自动重试，用户端不会感知到错误，降低了<code>Agent</code>的开发难度，同时也节省了重试的 Token 开销。<br> 正是由于这些好处，越来越多的 AI <code>Agent</code>从<code>System Prompt</code>转向了<code>Function Calling</code>。</p><p>可<code>Function Calling</code>也有问题，就是它没有统一的标准。每个大模型厂商的 API 定义都不一样，甚至一些开源模型还不支持<code>Function Calling</code>，所以要写一个跨模型通用的<code>Agent</code>是挺麻烦的。因此<code>System Prompt</code>和<code>Function Calling</code>这两种方式目前在市面上是并存的。</p><h3 id="_1-5-mcp" tabindex="-1"><a class="header-anchor" href="#_1-5-mcp"><span>1.5 MCP</span></a></h3><p>前面说的都是<code>Agent</code>和 AI 模型之间的通信方式，接下来说说<code>Agent</code>和<code>Agent Tool</code>是怎么通信的。<br> 最简单的方式就是把<code>Agent</code>和<code>Agent Tool</code>写在一个程序中，直接通过函数调用即可，这也是当前大多数<code>Agent</code>的做法。但这样其实耦合性比较高，有些<code>Agent Tool</code>是统一的，比如，浏览网页、读取文件、查找目录等，可能多个<code>Agent</code>有一部分相同的功能，总不能把相关函数在每个<code>Agent</code>中都写一次吧，这样要维护的时候就很麻烦。于是就有了一个办法，把所<code>Agent Tool</code>变成服务统一托管，所有的<code>Agent</code>都来调用服务，这就是<code>MCP</code>(Model Context Protocol, 模型上下文协议)。<br><code>MCP</code>是一种通信协议，专门用来规范<code>Agent</code>和<code>Agent Tool</code>服务之间的交互，运行<code>Agent Tool</code>服务叫做 MCP Server，调用它的<code>Agent</code>叫做 MCP Client。MCP 规定了 Server 与 Client 之间如何通信，以及 Server 需要提供哪些接口，比如要有，可以查询 Server 中有哪些 Tool 的接口，Tool 的描述、参数、返回格式的接口 等。除了可以调用 Tool 的这种方式来获取数据，MCP 服务也可以直接提供数据，如 提供文件读写的服务叫做 Resource，为 Agent 提供提示词模板的叫 Prompt。MCP Server 和 Agent 可以不在一台服务器上，然后通过 HTTP 进行通信。</p><p>虽然 MCP 是为了 AI 而制定出来的通信标准，但它本身和 AI 模型没有关系，它不关心 Agent 用的哪种 AI 模型，它只是负责帮 Agent 管理 Tool、Resource 和 Prompt。</p><h2 id="_2-组合流程" tabindex="-1"><a class="header-anchor" href="#_2-组合流程"><span>2. 组合流程</span></a></h2><p>在熟悉了这些 AI 名词后，我们来梳理下，看看一个组合后的流程是什么样的。</p>`,16)),s(t,{code:"eJyVk0tL60AUx/f9FOfuvHCTe69vg1RqRXAhCCouxEWVoQTSRNOodZdakdpqqfhutT7wUQRtBQWtSr9MZiau/AqeNOKzRd0MIXPm9/+f858RBMFjyIZCJOC3czQdB18P2MUYX82zqyjPJz1OhSdMJiaJOka65EBQD4Q8ACy+DILXC74gUY26Xn8f+BUZP39L8F8EezZDz9J8/Y6ZKesmThO5DjzzqbZCGNA0pfKzn+hTREdAvYhmtlCBLZhse6FSATwzZ5X3WbSAoI9HQKhhpUGEqgy2WYBIJFLTk6+H5fdpLilBowjDg2Gi9+laaNwYkap0Ntw/EzZIyK342z2pjhmypvoDiiKrwRGp3XXgGHDFvY7ss0CtGTaJUMezlyx19BFIszl6uIQl1v0e9vOwcf5wsGkfR93Qhshop65No2G7vGVdnzqqP5h8s4jY8jsOSyRcDbZ7ZBcOUJLfrrDctpvQT8JowZ5cCI0XrWvTKmXdgeAehvHnZflGLK14xyoNW6X5V680nXoVKM2/1agi8UUEbY5dc8c2Y8jha6cIf5k9vYhapSQ9zDzeLeJK13f47A2PnbHiJU2f/KrZAE4M38c/8UvAE//Ins0=",title:"eJx7vrvl6YQOBUdPhRcbmp9PWfFsa+PzFd0AlZENYg=="}),e[8]||(e[8]=a('<p>通过这个流程，我们可以看出：<code>System Prompt</code>、<code>User Prompt</code>、<code>Agent</code>、<code>Agent Tool</code>、<code>Function Calling</code>、<code>MCP</code>、<code>AI模型</code>之间的关系了。它们不是取代关系，而是相互结合，像齿轮一样传动，一起构成了AI自动化协作的完整体系。</p><h2 id="_3-结语" tabindex="-1"><a class="header-anchor" href="#_3-结语"><span>3. 结语</span></a></h2><p>AI 的猛烈发展给现代社会带来了不小的冲击，有些人会担心被 AI 取代而感到焦虑，在未来 AI 发展到什么程度我们不得而知，但从历史来看，每一次的技术革新，人们都是被时代的洪流推着向前走，新的变革也会带来新的机遇。既然如此，何不干脆积极面对技术革新，享受新技术带来的改变，在机遇中寻找发展。它也许会改变我们过去的生活/工作方式，但学会适应变化，新的方式可能会更好！</p><div class="hint-container note"><p class="hint-container-title">本文参考</p><ul><li><a href="https://www.bilibili.com/video/BV1aeLqzUE6L?spm_id_from=333.788.player.switch&amp;vd_source=3176ee7b546aa5c6726ec17363c3bb02" target="_blank" rel="noopener noreferrer">10分钟讲清楚 Prompt, Agent, MCP 是什么</a></li></ul></div>',4))])}const m=c(h,[["render",A]]),P=JSON.parse('{"path":"/article/pkfad9hg/","title":"理解Prompt,Agnet,MCP是什么","lang":"zh-CN","frontmatter":{"title":"理解Prompt,Agnet,MCP是什么","tags":["Prompt","Agnet","MCP"],"categories":["AI"],"createTime":"2025/05/06 11:41:34","permalink":"/article/pkfad9hg/"},"readingTime":{"minutes":10.19,"words":3058},"git":{"createdTime":1769985102000,"updatedTime":1769985102000,"contributors":[{"name":"Mayee","username":"Mayee","email":"may675154357@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Mayee?v=4","url":"https://github.com/Mayee"}]},"filePathRelative":"blog/1.后端/4.AI/1.理解Prompt,Agnet,MCP是什么.md","headers":[],"categoryList":[{"id":"fcf595","sort":1,"name":"后端"},{"id":"d96399","sort":4,"name":"AI"}]}');export{m as comp,P as data};
